{-# LANGUAGE NoImplicitPrelude #-}

module Main (main) where

import qualified ExploitableSwapFixDatum as OnChain
import           Prelude (IO, fst, snd, Num ((-), (+)), ($), Integer, Monad (return))
import           Test.Tasty (defaultMain, testGroup, TestTree)
import           Plutus.Model (Run, mustFail, testNoErrors, adaValue
                             , defaultBabbage, TypedValidator(TypedValidator)
                             , toV2, UserSpend, Tx, DatumMode (InlineDatum), payToScript, userSpend, payToKey, spendScript, newUser, spend, submitTx, utxoAt, valueAt, logError)
import           Plutus.V2.Ledger.Api (PubKeyHash, Value, TxOutRef, TxOut, txOutValue)

import           Control.Category ((.))
import           Control.Monad (replicateM, (>>=), mapM, unless, (>>), when)
import           Control.Applicative ((<*>))

import           Data.Functor ((<&>), (<$>))
import           Data.Monoid ((<>))
import           Data.Foldable (foldl)
import           Data.Eq ((==))
import           Data.Bool ((&&), Bool(..))
import           Data.String (String)

data LockTxData = LockTxData
  { identifier    :: Integer
  , price         :: Integer
  , lockedValue   :: Integer
  }

newtype SpendTxData = SpendTxData { paidValue :: Integer }

main :: IO ()
main = defaultMain
  $ do
    testGroup
      "UnitTest ExploitableSwap Validator"
      [
        testGroup "HappyPath" [
           happyPath "User 1 locks assets into one UTxO and user 2 pay correct price." $ testScript True [LockTxData 1 200 100] (SpendTxData 200)
        ]
        , testGroup "ErrorPath" [
           errorPath "User 1 locks assets into one UTxO and user 2 try to pay less then price." $ testScript True [LockTxData 1 200 100] (SpendTxData 100)
           , errorPath "User 1 locks assets into one UTxO and user 2 try to pay more then price." $ testScript True [LockTxData 1 200 100] (SpendTxData 300)
           , errorPath "User 1 locks assets into three UTxO and user 2 try to takes them all with correct price." $ testScript False [LockTxData 1 200 100, LockTxData 2 200 100, LockTxData 3 200 100] (SpendTxData 200)
        ]
      ]
  where
    errorPath :: String -> Run a -> TestTree
    errorPath msg = happyPath msg . mustFail

    happyPath :: String -> Run a -> TestTree
    happyPath = testNoErrors (adaValue 10000000) defaultBabbage

validatorScript :: TypedValidator OnChain.DatumSwap Integer
validatorScript = TypedValidator $ toV2 OnChain.validator

lockingTransaction :: PubKeyHash -> LockTxData -> UserSpend -> Tx
lockingTransaction beneficiary lockTxData utxosWithChange =
  spendUtxos <> txOutput
  where
    spendUtxos :: Tx
    spendUtxos = userSpend utxosWithChange

    txOutput :: Tx
    txOutput = payToScript validatorScript buildDatum valueAda
      where
        valueAda = adaValue $ lockedValue lockTxData
        getPrice = price lockTxData
        getIdentifier = identifier lockTxData

        buildDatum :: DatumMode OnChain.DatumSwap
        buildDatum =
          InlineDatum $ OnChain.DatumSwap beneficiary getPrice getIdentifier

consumingTransaction :: PubKeyHash -> LockTxData -> PubKeyHash -> [(TxOutRef, TxOut)] -> UserSpend -> Tx
consumingTransaction beneficiary lockTxData pkh scriptRefUTxOs userUtxosWithChange =
  foldl (<>) (payToUserPkh <> payToBeneficiary <> spendFromUserUtxos)  spendFromValidatorUtxos
  where
    getPrice = price lockTxData
    getIdentifier = identifier lockTxData
    buildDataum :: OnChain.DatumSwap
    buildDataum = OnChain.DatumSwap beneficiary getPrice getIdentifier

    spendFromUserUtxos :: Tx      -- signer has to spend to pay to beneficiary
    spendFromUserUtxos = userSpend userUtxosWithChange

    spendFromValidatorUtxos :: [Tx]
    spendFromValidatorUtxos = scriptRefUTxOs <&> fst <&> spendValidatorUtxo

    payToUserPkh :: Tx      -- signer take ADA locked at script
    payToUserPkh = payToKey pkh $ getValue scriptRefUTxOs

    payToBeneficiary :: Tx
    payToBeneficiary = payToKey beneficiary $ adaValue getPrice


    getValue :: [(TxOutRef, TxOut)] -> Value
    getValue utxos = foldl (<>) (adaValue 0) $ utxos <&> snd <&> txOutValue

    spendValidatorUtxo :: TxOutRef -> Tx
    spendValidatorUtxo txOutRef = spendScript
      validatorScript
      txOutRef
      getIdentifier
      buildDataum

---------------------------------------------------------------------------------------------------
------------------------------------- TESTING REDEEMERS -------------------------------------------

sendToScript :: [LockTxData] -> PubKeyHash -> Run ()
sendToScript [] _ = return ()
sendToScript (lockTxData:rest) pkh =
  spend pkh (adaValue $ lockedValue lockTxData)     -- get inputs and change output for locking tx
    <&> lockingTransaction pkh lockTxData           -- create locking transaction
    >>= submitTx pkh                                -- submit transaction
    >> sendToScript rest pkh                        -- process next

totalLockedValue :: [LockTxData] -> Integer
totalLockedValue ls = let
                        allValues = lockedValue <$> ls
                      in foldl (+) 0 allValues

-- Function to test if both creating and consuming script UTxOs works properly
testScript :: Bool -> [LockTxData] -> SpendTxData-> Run ()
testScript checkBalance lockTxDataLst spendTxData = do
  let initialBalance = 1000
  [pkh_1, pkh_2] <- replicateM 2 $ newUser $ adaValue initialBalance

  let paidValueInAda = adaValue $ paidValue spendTxData

  sendToScript lockTxDataLst pkh_1

  let (head:_) = lockTxDataLst
  (utxoAt validatorScript <&> (,)) <*> (spend pkh_2 paidValueInAda)
    <&> (\(scriptUtxos, userUtxos) -> consumingTransaction pkh_1 head pkh_2 scriptUtxos userUtxos)
    >>= submitTx pkh_2

  let expectedBalancePkh1 = adaValue $ initialBalance - totalLockedValue lockTxDataLst  +  paidValue spendTxData
      expectedBalancePkh2 =
        adaValue $ initialBalance + totalLockedValue lockTxDataLst - paidValue spendTxData

  when checkBalance $
    mapM valueAt [pkh_1, pkh_2]                                       -- get final balances
    <&> (\[v1, v2] -> v1 == expectedBalancePkh1 && v2 == expectedBalancePkh2)    -- check if match expected balances
    >>= (`unless` logError "Unexpected final balances")             -- log message if not expected balances
