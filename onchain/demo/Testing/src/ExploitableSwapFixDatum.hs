{-# LANGUAGE DataKinds           #-}
{-# LANGUAGE ImportQualifiedPost #-}
{-# LANGUAGE NoImplicitPrelude   #-}
{-# LANGUAGE OverloadedStrings   #-}
{-# LANGUAGE TemplateHaskell     #-}

module ExploitableSwapFixDatum where

import           Plutus.V2.Ledger.Api      ( PubKeyHash, Validator, mkValidatorScript, adaToken, adaSymbol, singleton, TxInfo)
import           Plutus.V2.Ledger.Contexts (valuePaidTo, scriptContextTxInfo, ScriptContext)
import           PlutusTx                  (compile, unstableMakeIsData)
import           PlutusTx.Builtins         (BuiltinData, Integer)
import           PlutusTx.Prelude          ((==), traceIfFalse, Bool, (&&))
import           Utils                     (wrapValidator)

---------------------------------------------------------------------------------------------------
----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------

data DatumSwap = DatumSwap
  { beneficiary :: PubKeyHash
  , price       :: Integer
  , identifier  :: Integer
  }
PlutusTx.unstableMakeIsData ''DatumSwap

{-# INLINABLE mkValidator #-}
mkValidator :: DatumSwap -> Integer -> ScriptContext -> Bool
mkValidator ds r ctx =  traceIfFalse "Hey! You have to pay the owner!" outputToBeneficiary
                        && traceIfFalse "Hey! You porovide wrong redeemer!" checkRedeemer
    where
        txInfo :: TxInfo
        txInfo = scriptContextTxInfo ctx

        outputToBeneficiary :: Bool
        outputToBeneficiary =
          valuePaidTo txInfo (beneficiary ds) == singleton adaSymbol adaToken (price ds)

        checkRedeemer :: Bool
        checkRedeemer = identifier ds == r

{-# INLINABLE  mkWrappedValidator #-}
mkWrappedValidator :: BuiltinData -> BuiltinData -> BuiltinData -> ()
mkWrappedValidator = wrapValidator mkValidator


validator :: Validator
validator = mkValidatorScript $$(compile [|| mkWrappedValidator ||])
