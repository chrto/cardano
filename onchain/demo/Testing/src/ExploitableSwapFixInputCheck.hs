{-# LANGUAGE DataKinds           #-}
{-# LANGUAGE ImportQualifiedPost #-}
{-# LANGUAGE NoImplicitPrelude   #-}
{-# LANGUAGE OverloadedStrings   #-}
{-# LANGUAGE TemplateHaskell     #-}

module ExploitableSwapFixInputCheck where

import           Plutus.V2.Ledger.Api      ( PubKeyHash, Validator, mkValidatorScript, adaToken, adaSymbol, singleton, Address (addressCredential), Credential (ScriptCredential))
import           Plutus.V2.Ledger.Contexts (valuePaidTo, scriptContextTxInfo, ScriptContext, TxInfo (txInfoInputs), findOwnInput, TxInInfo (txInInfoResolved), TxOut (txOutAddress), ownHash)
import           PlutusTx                  (compile, unstableMakeIsData)
import           PlutusTx.Builtins         (BuiltinData, Integer)
import           PlutusTx.Prelude          (Bool (..), (==), traceIfFalse, (&&), Maybe (..), (<$>), filter, (.))
import           Utils                     (wrapValidator)

---------------------------------------------------------------------------------------------------
----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------

data DatumSwap = DatumSwap
  { beneficiary :: PubKeyHash
  , price       :: Integer
  }
PlutusTx.unstableMakeIsData ''DatumSwap

{-# INLINABLE mkValidator #-}
mkValidator :: DatumSwap -> () -> ScriptContext -> Bool
mkValidator ds _ ctx = traceIfFalse "Hey! You have to pay the owner!" outputToBeneficiary
                       && traceIfFalse "Hey! You can spend only one UTxO" hasOneInput
    where
        txInfo :: TxInfo
        txInfo = scriptContextTxInfo ctx

        txInputs :: [TxInInfo]
        txInputs = txInfoInputs txInfo

        outputToBeneficiary :: Bool
        outputToBeneficiary =
          valuePaidTo txInfo (beneficiary ds) == singleton adaSymbol adaToken (price ds)

        hasOneInput :: Bool
        hasOneInput = case  findOwnInput ctx  of
          Just txInInfo ->  let currentAddress = getAddress txInInfo
                                allInputAddresses = getAddress <$> txInputs

                                getAddress :: TxInInfo -> Address
                                getAddress = txOutAddress . txInInfoResolved
                            in case filter (currentAddress ==) allInputAddresses of
                              [_] -> True
                              _ -> False
          Nothing -> False

        hasOneInput' :: Bool
        hasOneInput' = case getScriptInputs of
                          [_] -> True
                          _   -> False

        getScriptInputs :: [TxInInfo]
        getScriptInputs = filter isScriptInput txInputs
          where
            getAddressCredential :: TxInInfo -> Credential
            getAddressCredential = addressCredential . txOutAddress . txInInfoResolved

            isScriptInput :: TxInInfo -> Bool
            isScriptInput i = case getAddressCredential i of
                ScriptCredential vh -> vh == ownHash ctx -- Check that the validator required to spend this output is the current one
                _                   -> False

{-# INLINABLE  mkWrappedValidator #-}
mkWrappedValidator :: BuiltinData -> BuiltinData -> BuiltinData -> ()
mkWrappedValidator = wrapValidator mkValidator


validator :: Validator
validator = mkValidatorScript $$(compile [|| mkWrappedValidator ||])
