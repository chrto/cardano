{-# LANGUAGE NoImplicitPrelude #-}
{-# LANGUAGE OverloadedStrings #-}

module Main (main) where

import qualified ExploitableSwapFixInputCheck as OnChain
import           Prelude (IO, fst, snd, Num ((-), (*)), ($), Integer, replicate, fromIntegral, uncurry, fromInteger)
import           Test.Tasty (defaultMain, testGroup, TestTree)
import           Plutus.Model (Run, mustFail, testNoErrors, adaValue
                             , defaultBabbage, TypedValidator(TypedValidator)
                             , toV2, UserSpend, Tx, DatumMode (HashDatum), payToScript, userSpend, payToKey, spendScript, newUser, spend, submitTx, utxoAt, valueAt, logError, FakeCoin (FakeCoin), fakeValue)
import           Plutus.V2.Ledger.Api (PubKeyHash, Value, TxOutRef, TxOut, txOutValue)

import           Control.Category ((.))
import           Control.Monad (replicateM_, replicateM, (>>=), mapM, unless, when)
import           Control.Applicative ((<*>))

import           Data.Functor ((<&>))
import           Data.Monoid ((<>))
import           Data.Foldable (foldl)
import           Data.Eq ((==))
import           Data.Bool ((&&), Bool(..))
import           Data.String (String)

main :: IO ()
main = defaultMain
  $ do
    testGroup
      "UnitTest ExploitableSwap Validator"
      [
        testGroup "HappyPath" [
           happyPath "User 1 locks assets into one UTxO and user 2 pay correct price." $ testScript True 1 200 100 200
        ]
        , testGroup "ErrorPath" [
           errorPath "User 1 locks assets into one UTxO and user 2 try to pay less then price." $ testScript True 1 200 100 100
           , errorPath "User 1 locks assets into one UTxO and user 2 try to pay more then price." $ testScript True 1 200 100 300
           , errorPath "User 1 locks assets into three UTxO and user 2 try to takes them all with correct price." $ testScript True 3 200 100 200
        ]
      ]
  where
    errorPath :: String -> Run a -> TestTree
    errorPath msg = happyPath msg . mustFail

    happyPath :: String -> Run a -> TestTree
    happyPath =
      testNoErrors (adaValue 10000000 <> fakeValue xToken 1000) defaultBabbage

xToken :: FakeCoin
xToken = FakeCoin "xrt-Cool-Token"

validatorScript :: TypedValidator OnChain.DatumSwap ()
validatorScript = TypedValidator $ toV2 OnChain.validator

lockingTransaction :: PubKeyHash -> Integer -> UserSpend -> Value -> Tx
lockingTransaction beneficiary price utxosWithChange value = spendUtxos <> txOutput
  where
    spendUtxos :: Tx
    spendUtxos = userSpend utxosWithChange

    txOutput :: Tx
    txOutput = payToScript validatorScript buildDatum value
      where
        buildDatum :: DatumMode OnChain.DatumSwap
        buildDatum = HashDatum $ OnChain.DatumSwap beneficiary price

consumingTransaction :: PubKeyHash -> Integer -> PubKeyHash -> [(TxOutRef, TxOut)] -> UserSpend -> Tx
consumingTransaction beneficiary price pkh scriptRefUTxOs userUtxosWithChange =
  foldl (<>) (payToUserPkh <> payToBeneficiary <> spendFromUserUtxos)  spendFromValidatorUtxos
  where
    buildDataum :: OnChain.DatumSwap
    buildDataum = OnChain.DatumSwap beneficiary price

    spendFromUserUtxos :: Tx      -- signer has to spend to pay to beneficiary
    spendFromUserUtxos = userSpend userUtxosWithChange

    spendFromValidatorUtxos :: [Tx]
    spendFromValidatorUtxos = scriptRefUTxOs <&> fst <&> spendValidatorUtxo

    payToUserPkh :: Tx      -- signer take ADA locked at script
    payToUserPkh = payToKey pkh $ getValue scriptRefUTxOs

    payToBeneficiary :: Tx
    payToBeneficiary = payToKey beneficiary $ adaValue price


    getValue :: [(TxOutRef, TxOut)] -> Value
    getValue utxos = foldl (<>) (adaValue 0) $ utxos <&> snd <&> txOutValue

    spendValidatorUtxo :: TxOutRef -> Tx
    spendValidatorUtxo txOutRef = spendScript
      validatorScript
      txOutRef
      ()
      buildDataum

---------------------------------------------------------------------------------------------------
------------------------------------- TESTING REDEEMERS -------------------------------------------

-- Function to test if both creating and consuming script UTxOs works properly
testScript :: Bool -> Integer -> Integer -> Integer -> Integer -> Run ()
testScript checkBalance cnt price lockedTokenCnt paidValue = do
  let initialAda = 1000
      initialXToken = 500

  [pkh_1, pkh_2] <- replicateM 2 $ newUser (adaValue initialAda <> fakeValue xToken initialXToken )

  let lockedValue = fakeValue xToken lockedTokenCnt
  let paidValueInAda = adaValue paidValue

  replicateM_ (fromInteger cnt) $ spend pkh_1 lockedValue         -- get inputs and change output for locking tx
    <&> (\sp -> lockingTransaction pkh_1 price sp lockedValue)    -- create locking transaction
    >>= submitTx pkh_1                                            -- submit transaction

  (utxoAt validatorScript <&> (,)) <*> (spend pkh_2 paidValueInAda)
    <&> uncurry  (consumingTransaction pkh_1 price pkh_2)
    >>= submitTx pkh_2

  let expectedBalancePkh1 = foldl (<>) (adaValue initialAda <> fakeValue xToken (initialXToken - cnt * lockedTokenCnt)) (replicate (fromIntegral cnt) paidValueInAda )
      expectedBalancePkh2 = foldl (<>) (fakeValue xToken initialXToken <> adaValue (initialAda - cnt * paidValue))      (replicate (fromIntegral cnt) lockedValue)

  when checkBalance $
     mapM valueAt [pkh_1, pkh_2]                                                  -- get final balances
      <&> (\[v1, v2] -> v1 == expectedBalancePkh1 && v2 == expectedBalancePkh2)   -- check if match expected balances
      >>= (`unless` logError "Unexpected final balances")                         -- log message if not expected balances
